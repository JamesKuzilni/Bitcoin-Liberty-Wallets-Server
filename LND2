#!/usr/bin/env python3
import os
import subprocess
import wget
import tarfile
import random
import string
import time
import requests
import shutil

def create_lnd_config_file():
    # Predefined values
    rpcusername = "rpcusername"
    rpcpassword = "rpcpassword"
    ubuntuusername = "humble"
    nameoflightningnode = "nameoflightningnode"

    # Define the configuration text
    config_text = f"""\
listen=0.0.0.0:9735
tlsextraip=0.0.0.0
tlsextradomain=0.0.0.0
wallet-unlock-password-file=/home/{ubuntuusername}/.lnd/password.txt
wallet-unlock-allow-create=true
alias={nameoflightningnode}
rpclisten=localhost:10009
restlisten=0.0.0.0:8080
bitcoin.active=true
bitcoin.mainnet=true
bitcoin.node=bitcoind
bitcoind.dir=~/.bitcoin
bitcoind.config=~/.bitcoin/bitcoin.conf
bitcoind.rpcuser={rpcusername}
bitcoind.rpcpass={rpcpassword}
bitcoind.zmqpubrawblock=tcp://127.0.0.1:28332
bitcoind.zmqpubrawtx=tcp://127.0.0.1:28333
; tor.active=true
; tor.streamisolation=true
; tor.v3=true
"""

    # Define the path to the ~/.lnd directory
    lnd_directory = os.path.join(os.path.expanduser('~'), '.lnd')

    # Create the directory if it doesn't exist
    if not os.path.exists(lnd_directory):
        os.makedirs(lnd_directory)

    # Define the path to the configuration file
    config_file_path = os.path.join(lnd_directory, 'lnd.conf')

    # Write the configuration text to the file
    with open(config_file_path, 'w') as config_file:
   	 config_file.write(config_text)

    print(f'Created config file {config_file_path}')

if __name__ == "__main__":
    create_lnd_config_file()

def create_lnd_service(system_username):
    file_path = "/etc/systemd/system/lnd.service"
    content = f'''\
# A sample systemd service file for lnd running with a bitcoind service.

[Unit]
Description=Lightning Network Daemon

# Make sure lnd starts after bitcoind is ready
Requires=bitcoind.service
After=bitcoind.service

[Service]
ExecStart=/usr/local/bin/lnd
ExecStop=/usr/local/bin/lncli stop

# Replace these with the user:group that will run lnd
User={system_username}
Group={system_username}

# Try restarting lnd if it stops due to a failure
Restart=on-failure
RestartSec=60

# Type=notify is required for lnd to notify systemd when it is ready
Type=notify

# An extended timeout period is needed to allow for database compaction
# and other time-intensive operations during startup. We also extend the
# stop timeout to ensure graceful shutdowns of lnd.
TimeoutStartSec=1200
TimeoutStopSec=3600

# Hardening Measures
####################

# Mount /usr, /boot/ and /etc read-only for the process.
ProtectSystem=full

# Disallow the process and all of its children to gain
# new privileges through execve().
NoNewPrivileges=true

# Use a new /dev namespace only populated with API pseudo devices
# such as /dev/null, /dev/zero, and /dev/random.
PrivateDevices=true

# Deny the creation of writable and executable memory mappings.
MemoryDenyWriteExecute=true

[Install]
WantedBy=multi-user.target
'''

    # Write the content to a temporary file
    temp_file_path = "/tmp/lnd.service"
    with open(temp_file_path, 'w') as file:
        file.write(content)

    # Use sudo to move the temporary file to the target directory
    move_command = ["sudo", "mv", temp_file_path, file_path]
    subprocess.run(move_command, check=True)

    # Set the correct ownership and permissions for the service file
    chown_command = ["sudo", "chown", "root:root", file_path]
    subprocess.run(chown_command, check=True)
    chmod_command = ["sudo", "chmod", "644", file_path]
    subprocess.run(chmod_command, check=True)

    # Reload systemd configuration
    reload_command = ["sudo", "systemctl", "daemon-reload"]
    subprocess.run(reload_command, check=True)

    # Enable the lnd service
    enable_command = ["sudo", "systemctl", "enable", "lnd.service"]
    subprocess.run(enable_command, check=True)

    # Start the lnd service
    start_command = ["sudo", "systemctl", "start", "lnd.service"]
    subprocess.run(start_command, check=True)

if __name__ == "__main__":
    system_username = "humble"  # Replace with the desired username
    create_lnd_service(system_username)

# Define the URL of the Node.js tar.xz file and the target directory
url = "https://nodejs.org/dist/v18.18.0/node-v18.18.0-linux-x64.tar.xz"
download_dir = os.path.expanduser("~/Downloads")

# Create the target directory if it doesn't exist
os.makedirs(download_dir, exist_ok=True)

# Define the local file path for the downloaded tar.xz file
local_file_path = os.path.join(download_dir, "node-v18.18.0-linux-x64.tar.xz")

# Download the Node.js tar.xz file
response = requests.get(url)
if response.status_code == 200:
    with open(local_file_path, 'wb') as file:
        file.write(response.content)
else:
    print(f"Failed to download {url}. Status code: {response.status_code}")
    exit(1)

# Extract the downloaded tar.xz file
try:
    with tarfile.open(local_file_path, 'r:xz') as tar:
        tar.extractall(path=download_dir)
    print(f"Node.js has been extracted to {download_dir}")
except tarfile.TarError as e:
    print(f"Error extracting the tar.xz file: {str(e)}")
    exit(1)

# Define the source and destination directories
source_dir = os.path.expanduser("~/Downloads/node-v18.18.0-linux-x64")
destination_dir = os.path.expanduser("~")

# Check if the source directory exists
if not os.path.exists(source_dir):
    print(f"Source directory '{source_dir}' does not exist.")
    exit(1)

# Check if the destination directory already exists; if not, create it
if not os.path.exists(destination_dir):
    os.makedirs(destination_dir)

# Rename and move the source directory to the destination directory
new_destination = os.path.join(destination_dir, "nodejs")

try:
    shutil.move(source_dir, new_destination)
    print(f"Moved '{source_dir}' to '{new_destination}'")
except shutil.Error as e:
    print(f"Error moving the directory: {str(e)}")
    exit(1)

# Define the path to the .bashrc file
bashrc_path = os.path.expanduser("~/.bashrc")

# Define the line to be added
line_to_add = 'PATH=$PATH:/home/humble/nodejs/bin\n'

# Check if the .bashrc file exists
if not os.path.exists(bashrc_path):
    print(f"The .bashrc file '{bashrc_path}' does not exist.")
    exit(1)

# Check if the line is already present in .bashrc
with open(bashrc_path, 'r') as file:
    if line_to_add in file.read():
        print("The line is already present in .bashrc.")
        exit(0)

# Append the line to .bashrc
with open(bashrc_path, 'a') as file:
    file.write(line_to_add)

print("The line has been added to .bashrc.")

try:
    # Run the 'exit' command to terminate the SSH session
    subprocess.run(["exit"], shell=True, check=True)
    print("SSH session has been terminated.")
except subprocess.CalledProcessError as e:
    print(f"Error executing 'exit' command: {e}")
except Exception as e:
    print(f"An error occurred: {e}")


